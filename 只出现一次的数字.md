给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
```
   输入: [2,2,1]  
   输出: 1
```
```
   输入: [4,1,2,1,2]
   输出: 4
```


1. 与运算（&）

   参加运算的两个数据，按二进制位进行“与”运算。

   运算规则：0&0=0; 0&1=0; 1&0=0; 1&1=1;
   即：两位同时为“1”，结果才为“1”，否则为0

   例如：3&5 即 0000 0011 & 0000 0101 = 0000 0001 因此，3&5的值得1。

   例如：9&5 即 0000 1001 (9的二进制补码)&00000101 (5的二进制补码) =00000001 (1的二进制补码)可见9&5=1。

2. 或运算（|）
   参加运算的两个对象，按二进制位进行“或”运算。

   运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；

   即 ：参加运算的两个对象只要有一个为1，其值为1。

   例如:3|5　即 0000 0011 | 0000 0101 = 0000 0111 因此，3|5的值得7。　

   例如：9|5可写算式如下： 00001001|00000101 =00001101 (十进制为13)可见9|5=13

3. 异或运算（^）
   参加运算的两个数据，按二进制位进行“异或”运算。

   运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0；

   即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

   例如：9^5可写成算式如下： 00001001^00000101=00001100 (十进制为12)可见9^5=12所以很容易就能想到用异或运算所有相同元素都会互相抵消，剩下一个“单身狗”元素了。

```
class Solution {
    public int singleNumber(int[] nums) {
        int ans=nums[0];
        for (int i = 1; i < nums.length ; i++)
        {
            ans = ans ^ nums[i];
        }
        return ans;
    }
}
```
